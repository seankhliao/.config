#!/bin/zsh

mkdir -p $XDG_DATA_HOME/zsh

eval $(dircolors $XDG_CONFIG_HOME/dircolors)

setopt AUTOCD
setopt COMPLETE_IN_WORD
setopt LIST_PACKED
setopt EXTENDED_GLOB
setopt GLOB_DOTS
setopt EXTENDED_HISTORY
setopt HIST_FCNTL_LOCK
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_LEX_WORDS
setopt HIST_NO_FUNCTIONS
setopt HIST_NO_STORE
setopt HIST_REDUCE_BLANKS
setopt HIST_SAVE_NO_DUPS
setopt SHARE_HISTORY
setopt IGNORE_EOF
setopt INTERACTIVE_COMMENTS
setopt PIPE_FAIL
setopt NO_PROMPT_BANG
setopt NO_PROMPT_CR
setopt PROMPT_SUBST
setopt PROMPT_PERCENT

autoload -Uz add-zsh-hook
autoload -Uz compinit bashcompinit
autoload -Uz edit-command-line
autoload -Uz url-quote-magic
autoload -Uz vcs_info
autoload -Uz zmv

zmodload zsh/cap
zmodload zsh/datetime
zmodload zsh/stat
# zmodload zsh/zprof
zmodload zsh/zpty

zle -N self-insert url-quote-magic
zle -N _sudo_cmdline
zle -N history-substring-search-up
zle -N history-substring-search-down

function _sudo_cmdline() {
    [[ -z ${BUFFER} ]] && zle up-history
    [[ ${BUFFER} == sudo\ * ]] && BUFFER=${BUFFER#sudo } || BUFFER="sudo ${BUFFER}"
}

bindkey -e
bindkey "\e\e" _sudo_cmdline
bindkey '^[[A' history-substring-search-up
bindkey '\eOA' history-substring-search-up
bindkey '^[[B' history-substring-search-down
bindkey '\eOB' history-substring-search-down
bindkey '^[[H' beginning-of-line
bindkey '^[[F' end-of-line

zstyle ':completion:*' group-name ''
zstyle ':completion:*' gain-privileges true
zstyle ':completion:*' list-colors "${(@s.:.)LS_COLORS}"
zstyle ':completion:*' menu select
zstyle ':completion:*' rehash true
zstyle ':completion:*' use-cache true
zstyle ':completion:*' matcher-list '' \
    '+m:{a-z}={A-Z}' '+m:{A-Z}={a-z}' \
    'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
    'r:|?=** m:{a-z\-}={A-Z\_}'

zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:git:*' formats '%b'

compinit -d $XDG_CACHE_HOME/zcompdump
bashcompinit

complete -o nospace -C /usr/bin/kustomize kustomize
complete -o nospace -C /usr/bin/terraform terraform
# (( $+commands[skaffold] )) && source <(skaffold completion zsh)
# (( $+commands[kubectl] )) && source <(kubectl completion zsh)
# (( $+commands[gh] )) && source <(gh completion --shell zsh)
source ${ZDOTDIR}/_kubectl &>/dev/null || true
source /opt/google-cloud-sdk/completion.zsh.inc &>/dev/null || true

source ${ZDOTDIR}/prompt.zsh

# inline suggestion
export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=7'
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=40
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=1
source ${ZDOTDIR}/zsh-autosuggestions.zsh

source ${ZDOTDIR}/zsh-syntax-highlighting.zsh

source ${ZDOTDIR}/zsh-history-substring-search.zsh

# anonymous function
function {
    [[ -f $XDG_CONFIG_HOME/git/config ]] || return
    local start_alias=false
    while read line; do
        if $start_alias; then
            [[ $line =~ '\s*\[[a-z]*\]' ]] && return
            sub=${${line%%=*}// /}
            [[ $sub ]] && alias g${sub}="git ${sub}"
        else
            [[ $line =~ '\s*\[alias\]' ]] && start_alias=true
        fi
    done < $XDG_CONFIG_HOME/git/config
}

alias -s go='go run'
alias -s py='python'
(( $+commands[rg] ))      && alias grep='rg -S'                                                     || alias grep='grep --color=auto'
(( $+commands[exa] ))     && alias l='exa -l --git --time-style iso --group-directories-first'      || alias l='ls -lh --color=auto';
(( $+commands[exa] ))     && alias ll='exa -l -a --git --time-style iso --group-directories-first'  || alias ll='ls -alh --color=auto';
(( $+commands[nvim] ))    && alias v='nvim'                                                         || alias v='vim'
(( $+commands[nvim] ))    && alias vbare='nvim -u NONE'                                             || alias v='vim -u NONE'

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias .......='cd ../../../../../..'

alias cp='cp -v'
alias diff='diff --color=always'
alias ln='ln -v'
alias ls='ls --color'
alias mv='mv -v'
# alias sudo='sudo -E'

alias cr='google-chrome-stable'
alias g='git'
alias goupdate='rm $XDG_DATA_HOME/go/bin/go && gotip download && ln -s $XDG_DATA_HOME/go/bin/gotip $XDG_DATA_HOME/go/bin/go'
alias h='htop'
alias k='kubectl'
alias p='yay'
alias py='python3'
alias rg='rg -N -S -p'
alias s='ssh'
alias sc='sudo systemctl'
alias scu='systemctl --user'
alias tf='terraform'

function vsk(){
    nvim $(sk)
}

function gcamp_patch(){
    _check_tidy && \
    git commit -a -m "${*}" && \
    git push && \
    git push origin "$(_semver_next patch)"
}
function gcamp_minor(){
    _check_tidy && \
    git commit -a -m "${*}" && \
    git push && \
    git push origin "$(_semver_next minor)"
}

function gsall() {
    local bold=$(tput bold)
    local normal=$(tput sgr0)

    for dir in ./*; do
        if [[ -d ${dir} ]] && [[ -d ${dir}/.git ]]; then
            if ! git -C ${dir} diff-index --quiet HEAD || ! git -C ${dir} diff-index --quiet origin/main; then
                echo "\n${bold}$dir${normal}"
                git -C ${dir} log --oneline origin/main..HEAD
                git -C ${dir} status -s
            fi
        fi
    done
}

function md() {
    [[ -z ${1// } ]] && echo "no directory name gived" && return 1
    mkdir -p "$1" && cd "$1"
}

function t() {
    command tag -i "$@"
    source ${TAG_ALIAS_FILE:-/tmp/tag_aliases} 2>/dev/null
}

function mr() {
    local repo=${1// }
    [[ -z ${repo} ]] && echo "no repo name given" && return 1
    mkdir -p ${repo}
    cd ${repo}
    git init
    git commit --allow-empty -m "root-commit"
    git remote add origin s:${repo}

    cat << EOF > .gitignore
${repo}
EOF

    cat << EOF > README.md
# ${repo}

A repo for ${repo}

[![License](https://img.shields.io/github/license/seankhliao/${repo}.svg?style=flat-square)](LICENSE)
EOF

    cat << EOF > LICENSE
MIT License

Copyright (c) $(date +%Y) Sean Liao

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF
}

function mrgo() {
    local repo=${1// }
    [[ -z ${repo} ]] && echo "no repo name given" && return 1
    mr ${repo}
    go mod init go.seankhliao.com/${repo}

    cat << EOF > README.md
# ${repo}

A repo for ${repo}
[![pkg.go.dev](http://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](https://pkg.go.dev/go.seankhliao.com/${repo})
![Version](https://img.shields.io/github/v/tag/seankhliao/${repo}?sort=semver&style=flat-square)
[![License](https://img.shields.io/github/license/seankhliao/${repo}.svg?style=flat-square)](LICENSE)

\`\`\`go
import "go.seankhliao.com/${repo}"
\`\`\`

EOF

    cat << EOF > .dockerignore
.dockerignore
.git/
.github/
.gitignore

cloudbuild.yaml
Dockerfile
k8s/
LICENSE
Makefile
README.md
EOF

    cat << EOF > Dockerfile
FROM golang:alpine AS build

WORKDIR /workspace
COPY . .
RUN CGO_ENABLED=0 go build -trimpath -ldflags='-s -w' -o /bin/${repo}


FROM scratch

COPY --from=build /bin/${repo} /bin/

ENTRYPOINT [ "/bin/${repo}" ]
EOF

    cat << EOF > cloudbuild.yaml
substitutions:
  _IMG: stream
  _REG: us.gcr.io
tags:
  - \$\SHORT_SHA
  - \$\COMMIT_SHA
steps:
  - id: build-push
    name: gcr.io/kaniko-project/executor:latest
    args:
      - -c=.
      - -f=Dockerfile
      - -d=\$_REG/\$PROJECT_ID/\$_IMG:latest
      - -d=\$_REG/\$PROJECT_ID/\$_IMG:\$SHORT_SHA
      - --reproducible
      - --single-snapshot
  - id: deploy
    name: gcr.io/cloud-builders/kubectl:latest
    entrypoint: /bin/sh
    args:
      - -c
      - |
        set -ex; \
        sed -i 's/# newTag: IMAGE_TAG/newTag: "\$SHORT_SHA"/' k8s/kustomization.yaml && \
        /builder/kubectl.bash apply -k k8s
    env:
      - CLOUDSDK_COMPUTE_ZONE=us-central1-c
      - CLOUDSDK_CONTAINER_CLUSTER=cluster23
EOF
}

function testrepo() {
    set -xo pipefail
    local vers=$(( $(cat ${XDG_CONFIG_HOME}/testrepo-version)+1))
    local repo=testrepo-${vers}
    mkdir ${HOME}/${repo}
    cd ${HOME}/${repo}
    echo ${vers} > ${XDG_CONFIG_HOME}/testrepo-version
    git init
    git commit --allow-empty -m "root-commit"
    git remote add origin s:${repo}
    go mod init go.seankhliao.com/${repo}
}

function _check_tidy() {
    local currentdir=$(pwd)
    cd $(git rev-parse --show-toplevel)
    [[ ! -f go.mod ]] || go mod tidy
    [[ ! -d vendor ]] || go mod vendor
    cd "${currentdir}"
}


function _colortest () {
    for i in {0..255} ; do
        printf "\x1b[48;5;%sm%3d\e[0m " "$i" "$i"
        if (( i == 15 )) || (( i > 15 )) && (( (i-15) % 6 == 0 )); then
            printf "\n";
        fi
    done
}

function _semver_next() {
    if [[ "$1" != "major" ]] && [[ "$1" != "minor" ]] && [[ "$1" != "patch" ]]; then
        echo "please specify one of: major|minor|patch"
        return 1
    fi
    IFS=$'\n' local tags=($(git tag -l))
    if [ ${#tags[@]} -eq 0 ]; then
        git tag v0.0.1
        return
    fi
    local max=$tags[1]
    for t in $tags; do
        max=$(_semver_gt $max $t)
    done
    local v=$(_semver_bump $max $1)
    git tag $v
    echo $v
}

function _semver_gt() {
    local r="^v(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(\\-([0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*))?(\\+([0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*))?$"
    if [[ "$1" =~ $r ]]; then
        local v1=(${match[1]} ${match[2]} ${match[3]})
        if [[ "$2" =~ $r ]]; then
            local v2=(${match[1]} ${match[2]} ${match[3]})

            for i in 1 2 3; do
                local vv1=${v1[$i]}
                local vv2=${v2[$i]}
                if (( vv1 > vv2 )); then
                    echo "v${v1[1]}.${v1[2]}.${v1[3]}"
                    return 0
                elif (( vv1 < vv2 )); then
                    echo "v${v2[1]}.${v2[2]}.${v2[3]}"
                    return 0
                fi
            done
            echo "v${v1[1]}.${v1[2]}.${v1[3]}"
            return 0
        fi
    fi
    return 1
}

function _semver_bump() {
    local r="^v(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(\\-([0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*))?(\\+([0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*))?$"
    if [[ "$1" =~ $r ]]; then
        integer maj=${match[1]}
        integer min=${match[2]}
        integer pat=${match[3]}

        case "$2" in
            major)
                echo "v$(( maj + 1 )).0.0"
            ;;
            minor)
                echo "v${maj}.$(( min +1 )).0"
            ;;
            patch)
                echo "v${maj}.${min}.$(( pat + 1 ))"
            ;;
            *)
            echo "v${maj}.${min}.${pat}"
        esac
        return 0
    fi
    return 1
}
